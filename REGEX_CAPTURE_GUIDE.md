# 正则表达式捕获组功能说明

## 功能概述

FloatSort 现在支持在正则表达式条件中使用捕获组，并在目标路径中引用这些捕获组。这使得文件组织变得更加灵活和智能。

## 基本用法

### ⚠️ 重要提示

**正则表达式匹配的是包含扩展名的完整文件名**

例如：文件 `2024-03-15报告.txt` 的匹配对象是 `2024-03-15报告.txt`（包含 `.txt`）

### 两种使用模式

#### 模式 1：只用正则（精确控制）

适合需要精确匹配扩展名的场景。

- ✅ 在正则表达式中明确指定扩展名：`^(\d{4})-(\d{2})-(\d{2}).*\.txt$`
- ✅ 不添加"文件扩展名"条件
- ✅ 完全由正则控制匹配逻辑

#### 模式 2：扩展名 + 简化正则（推荐）

适合同一规则需要适配多种扩展名的场景。

- ✅ 正则表达式不包含扩展名：`^(\d{4})-(\d{2})-(\d{2}).*`
- ✅ 添加"文件扩展名"条件：`txt, pdf, docx`
- ✅ 正则专注于文件名规则，扩展名由独立条件控制

### 1. 创建正则表达式条件

在规则的"其他条件"中，选择"正则表达式"类型，然后输入包含捕获组的正则表达式。

**捕获组语法**：使用括号 `()` 包围需要捕获的部分。

### 2. 在目标路径中引用捕获组

在目标文件夹路径中，使用 `$1`, `$2`, `$3` 等占位符来引用对应的捕获组。

- `$1` 代表第一个捕获组
- `$2` 代表第二个捕获组
- `$3` 代表第三个捕获组
- 以此类推...

也支持 `${1}`, `${2}` 的格式。

## 实用示例

### 示例 1：按日期归档文件

**场景**：文件名包含日期，如 `2024-03-15报告.txt`，需要按年/月/日归档。

**配置**：
- **正则表达式**：`^(\d{4})-(\d{2})-(\d{2}).*\.txt$`
  - `(\d{4})`：捕获4位数字的年份 → `$1`
  - `(\d{2})`：捕获2位数字的月份 → `$2`
  - `(\d{2})`：捕获2位数字的日期 → `$3`
- **目标路径**：`D:/文档/$1年/$2月/$3日/`

**效果**：
- `2024-03-15报告.txt` → `D:/文档/2024年/03月/15日/2024-03-15报告.txt`
- `2024-12-25总结.txt` → `D:/文档/2024年/12月/25日/2024-12-25总结.txt`

### 示例 2：按项目编号分类

**场景**：文件名格式为 `PRJ-001-设计图.pdf`，需要按项目编号归档。

**配置**：
- **正则表达式**：`^PRJ-(\d{3})-.*\.pdf$`
  - `(\d{3})`：捕获3位项目编号 → `$1`
- **目标路径**：`D:/项目文档/项目-$1/`

**效果**：
- `PRJ-001-设计图.pdf` → `D:/项目文档/项目-001/PRJ-001-设计图.pdf`
- `PRJ-123-需求文档.pdf` → `D:/项目文档/项目-123/PRJ-123-需求文档.pdf`

### 示例 3：按客户和年份分类

**场景**：发票文件名格式为 `INV-张三-2024-001.pdf`。

**配置**：
- **正则表达式**：`^INV-(.+?)-(\d{4})-\d+\.pdf$`
  - `(.+?)`：捕获客户名称 → `$1`
  - `(\d{4})`：捕获年份 → `$2`
- **目标路径**：`D:/财务/$1/$2年发票/`

**效果**：
- `INV-张三-2024-001.pdf` → `D:/财务/张三/2024年发票/INV-张三-2024-001.pdf`
- `INV-李四-2023-005.pdf` → `D:/财务/李四/2023年发票/INV-李四-2023-005.pdf`

### 示例 4：两种模式对比

**场景**：按日期归档文档文件，支持 txt、pdf、docx 三种格式。

**模式 1 - 只用正则**：
```
条件：
  - 正则：^(\d{4})-(\d{2})-(\d{2}).*\.(txt|pdf|docx)$

目标：D:/文档/$1年/$2月/$3日/

优点：一个条件搞定
缺点：要修改支持的格式需要改正则
```

**模式 2 - 扩展名 + 简化正则**：
```
条件：
  - 扩展名：txt, pdf, docx
  - 正则：^(\d{4})-(\d{2})-(\d{2}).*

目标：D:/文档/$1年/$2月/$3日/

优点：扩展名和文件名规则分离，易维护
缺点：需要两个条件
```

**推荐**：大多数情况使用模式 2，更灵活且易于维护。

### 示例 5：提取版本号

**场景**：软件安装包名称包含版本号，如 `MyApp-v1.2.3-setup.exe`。

**配置**：
- **正则表达式**：`^(.+?)-v(\d+\.\d+\.\d+)-.*\.exe$`
  - `(.+?)`：捕获软件名称 → `$1`
  - `(\d+\.\d+\.\d+)`：捕获版本号 → `$2`
- **目标路径**：`D:/软件/$1/$2/`

**效果**：
- `MyApp-v1.2.3-setup.exe` → `D:/软件/MyApp/1.2.3/MyApp-v1.2.3-setup.exe`
- `OtherApp-v2.0.1-installer.exe` → `D:/软件/OtherApp/2.0.1/OtherApp-v2.0.1-installer.exe`

## 与其他占位符结合使用

捕获组可以与其他占位符（如 `{name}`, `{ext}`, `{year}` 等）一起使用：

**示例**：
- **正则表达式**：`^(PROJECT)-(\d+)-.*\.(.+)$`
- **目标路径**：`D:/归档/$1/$2/{year}/{month}/`
- **效果**：`PROJECT-123-报告.pdf` → `D:/归档/PROJECT/123/2024/10/`

## 正则表达式语法参考

### 常用元字符

- `.`：匹配任意单个字符
- `*`：匹配前面的字符0次或多次
- `+`：匹配前面的字符1次或多次
- `?`：匹配前面的字符0次或1次
- `^`：匹配字符串开头
- `$`：匹配字符串结尾
- `\d`：匹配数字（0-9）
- `\w`：匹配字母、数字或下划线
- `[abc]`：匹配方括号中的任意字符
- `[^abc]`：匹配不在方括号中的任意字符

### 捕获组

- `(pattern)`：捕获匹配的内容，可以用 `$1`, `$2` 等引用
- `(?:pattern)`：非捕获组，匹配但不捕获

### 数量限定符

- `{n}`：恰好匹配n次
- `{n,}`：至少匹配n次
- `{n,m}`：匹配n到m次

## 注意事项

1. **捕获组编号从1开始**：`$1` 是第一个捕获组，`$2` 是第二个，以此类推。

2. **捕获组必须存在**：如果在目标路径中使用了 `$1`，但正则表达式中没有对应的捕获组，该占位符将不会被替换。

3. **转义特殊字符**：正则表达式中的特殊字符（如 `.`, `*`, `+` 等）需要用反斜杠转义，例如 `\.` 匹配实际的点号。

4. **测试你的正则**：建议先在在线正则表达式测试工具（如 regex101.com）中测试你的正则表达式。

5. **贪婪vs非贪婪**：
   - `.*`：贪婪匹配（尽可能多地匹配）
   - `.*?`：非贪婪匹配（尽可能少地匹配）

## 故障排除

### 文件没有被正确归档

1. **检查正则表达式是否匹配**：在规则中点击"预览"，查看文件是否匹配规则。
2. **检查捕获组数量**：确保目标路径中使用的 `$n` 不超过正则表达式中的捕获组数量。
3. **查看活动日志**：在界面右下角查看详细的日志信息，了解文件处理过程。

### 正则表达式语法错误

如果正则表达式语法错误，规则将不会匹配任何文件。请检查：
- 括号是否配对
- 反斜杠转义是否正确
- 特殊字符是否需要转义

## 技术实现

### 后端实现

在 Rust 后端，使用 `regex` crate 的 `captures()` 方法提取捕获组：

```rust
if let Ok(regex) = Regex::new(pattern) {
    if let Some(caps) = regex.captures(&file_info.name) {
        // 提取所有捕获组（跳过第0个，因为它是整个匹配）
        for i in 1..caps.len() {
            if let Some(m) = caps.get(i) {
                regex_captures.push(m.as_str().to_string());
            }
        }
    }
}
```

在 `resolve_placeholders` 中替换占位符：

```rust
// 正则表达式捕获组 - 支持 $1, $2, $3... 或 ${1}, ${2}, ${3}...
for (i, capture) in regex_captures.iter().enumerate() {
    let index = i + 1;
    result = result.replace(&format!("${}", index), capture);
    result = result.replace(&format!("${{{}}}", index), capture);
}
```

### 前端实现

前端在条件输入界面增加了捕获组使用说明，并在目标路径的占位符标签中添加了 `$1`, `$2`, `$3`, `$4` 的快捷按钮。

## 版本信息

- **引入版本**：v0.2.0
- **最后更新**：2024-10-30

