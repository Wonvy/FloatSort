# FloatSort 拖拽功能说明

📅 更新日期：2025-10-28

---

## ✅ 问题修复

### 问题
在 V2 架构重构时，**拖拽文件/文件夹功能被意外移除**。

### 解决方案
已重新添加完整的拖拽支持，现在可以：
- ✅ 拖拽单个文件到窗口
- ✅ 拖拽多个文件到窗口
- ✅ 拖拽文件夹到窗口
- ✅ 支持批量确认（5个及以上）

---

## 🎯 拖拽功能工作原理

### 1. 监听 Tauri 拖拽事件

FloatSort 监听以下三个 Tauri 系统事件：

```javascript
// 文件拖入窗口时触发
listen('tauri://file-drop', event => {
    const files = event.payload;  // 文件路径数组
    // 处理拖入的文件...
});

// 文件在窗口上方悬停时触发（可选）
listen('tauri://file-drop-hover', event => {
    console.log('文件悬停');
});

// 拖拽取消时触发（可选）
listen('tauri://file-drop-cancelled', () => {
    console.log('拖拽已取消');
});
```

### 2. 智能批量处理

拖拽文件后的处理流程：

```
拖入文件
  ↓
添加到批量队列 (pendingBatch)
  ↓
文件数量 >= 5？
  ├─ 是 → 显示批量确认窗口
  │        用户可以查看所有文件
  │        点击"确认"后批量处理
  │
  └─ 否 → 直接自动处理
           逐个调用 process_file
```

### 3. 文件处理逻辑

```javascript
async function processDraggedFiles(files) {
    for (const filePath of files) {
        // 调用后端命令处理单个文件
        const result = await invoke('process_file', { path: filePath });
        
        if (result) {
            // 整理成功，显示详细路径
            addActivity(`✅ ${fileName}`, 'success', `从: ${filePath}<br>到: ${result}`);
        } else {
            // 未匹配任何规则
            addActivity(`⚠️ 未匹配规则: ${fileName}`);
        }
    }
}
```

---

## 🔧 后端处理

### process_file 命令

```rust
#[tauri::command]
async fn process_file(path: String, state: State<'_, AppState>) -> Result<String, String> {
    let config = state.config.lock().map_err(|e| e.to_string())?.clone();
    
    // 使用所有规则尝试整理文件
    let result = file_ops::organize_single_file(&path, &config.rules)
        .map_err(|e| e.to_string())?;
    
    // 更新统计
    let mut stats = state.stats.lock().map_err(|e| e.to_string())?;
    stats.files_processed += 1;
    if !result.is_empty() {
        stats.files_organized += 1;
    }
    
    Ok(result)  // 返回新路径，如果未整理则返回空字符串
}
```

### 规则匹配逻辑

```rust
pub fn organize_single_file(path: &str, rules: &[Rule]) -> Result<String> {
    let file_info = get_file_info(Path::new(path))?;
    let engine = RuleEngine::new(rules.to_vec());
    
    // 查找第一个匹配的规则
    if let Some(rule) = engine.find_matching_rule(&file_info) {
        // 应用规则的动作（移动、复制、重命名等）
        let dest_path = engine.get_destination_path(&rule.action, &file_info, base_path)?;
        
        // 执行文件操作
        move_file(Path::new(path), &PathBuf::from(dest_path))?;
        
        return Ok(dest_path);
    }
    
    Ok(String::new())  // 未匹配任何规则
}
```

---

## 📋 使用方法

### 方式 1：直接拖拽（少于 5 个文件）

1. 打开 FloatSort 窗口
2. 从文件管理器拖拽文件到窗口
3. 松开鼠标
4. **自动处理** - 立即整理文件
5. 在"活动"Tab 查看结果

**示例流程**：
```
拖入: report.pdf (3个文件)
  ↓
📥 拖入 3 个文件/文件夹
  ↓
🔄 开始处理: report.pdf
  ↓
✅ report.pdf
从: C:\Users\...\Desktop\report.pdf
到: C:\Users\...\Documents\2025\10\report.pdf
```

---

### 方式 2：批量确认（5 个及以上文件）

1. 打开 FloatSort 窗口
2. 从文件管理器拖拽多个文件（≥5个）到窗口
3. **批量确认窗口弹出**
4. 查看文件列表
5. 点击"确认整理"
6. 批量处理所有文件

**示例流程**：
```
拖入: 10个PDF文件
  ↓
📥 拖入 10 个文件/文件夹
  ↓
🔔 批量整理确认窗口弹出
   显示所有10个文件的列表
  ↓
点击"确认整理"
  ↓
逐个处理所有文件
  ↓
查看活动日志中的详细结果
```

---

## 🆚 拖拽 vs 自动监控

| 特性 | 拖拽整理 | 自动监控 |
|------|---------|---------|
| 触发方式 | 手动拖拽 | 自动检测 |
| 适用场景 | 临时整理、批量处理 | 持续监控、自动整理 |
| 规则应用 | 所有全局规则 | 文件夹关联的规则 |
| 处理时机 | 立即处理 | 文件变化时 |
| 确认机制 | 5个以上批量确认 | 5个以上批量确认 |
| 活动日志 | 显示详细路径 | 显示详细路径 |

---

## 🎯 最佳实践

### 场景 1：快速整理桌面文件
```
操作：
1. 选中桌面上的所有杂乱文件
2. 拖拽到 FloatSort 窗口
3. 确认批量整理
4. 文件自动归类到各个文件夹

优势：
- 快速清理桌面
- 无需手动设置监控
- 一次性批量处理
```

### 场景 2：临时整理下载文件
```
操作：
1. 打开下载文件夹
2. 选择需要整理的文件
3. 拖拽到 FloatSort 窗口
4. 查看整理结果

优势：
- 按需整理
- 不干扰其他文件
- 立即查看结果
```

### 场景 3：配合自动监控使用
```
设置：
1. 设置文件夹自动监控（如：下载文件夹）
2. 保持 FloatSort 运行

临时操作：
1. 遇到其他位置的文件需要整理
2. 拖拽到 FloatSort 窗口
3. 使用相同的规则自动整理

优势：
- 自动 + 手动结合
- 灵活处理各种场景
- 统一的整理规则
```

---

## 🐛 已知限制

### 1. 文件夹拖拽
- ⚠️ 拖拽文件夹时，后端会尝试处理文件夹本身
- ⚠️ 如果规则不匹配文件夹，会显示"未匹配规则"
- 💡 **建议**：只拖拽文件，不要拖拽文件夹

### 2. 规则优先级
- ⚠️ 拖拽文件使用**所有全局规则**进行匹配
- ⚠️ 不考虑文件夹的规则关联和排序
- ⚠️ 规则优先级由后端的 `priority` 字段决定
- 💡 **改进方向**：未来可以添加"拖拽时选择文件夹"功能

### 3. 批量确认
- ⚠️ 批量确认窗口不显示"目标位置预览"
- ⚠️ 只在处理后才能看到实际的整理结果
- 💡 **改进方向**：添加整理前的路径预览

---

## 🚀 未来改进方向

### 短期改进
1. **拖拽时选择文件夹**
   - 拖拽文件后，弹出文件夹选择器
   - 选择要应用的文件夹规则
   - 按照该文件夹的规则排序和优先级整理

2. **批量预览**
   - 在批量确认窗口中显示每个文件的预计目标位置
   - 允许用户单独取消某些文件的整理

3. **拖拽区域提示**
   - 添加可视化的拖拽区域
   - 悬停时高亮提示
   - 显示"拖拽文件到此处"文字

### 中期改进
1. **拖拽文件夹支持**
   - 递归处理文件夹内的所有文件
   - 保持文件夹结构
   - 批量显示所有子文件

2. **智能规则匹配**
   - 根据文件来源路径自动选择文件夹
   - 学习用户的拖拽习惯
   - 推荐最合适的规则

---

## 📝 技术细节

### 前端实现
```javascript
// 文件: ui/app_v2.js
// 行数: 169-237

// 监听拖拽事件
listen('tauri://file-drop', event => {
    const files = event.payload;
    
    // 添加到批量队列
    files.forEach(filePath => {
        appState.pendingBatch.push({
            path: filePath,
            name: fileName
        });
    });
    
    // 判断是否需要批量确认
    if (appState.pendingBatch.length >= appState.batchThreshold) {
        showBatchConfirm();
    } else {
        processDraggedFiles(files);
    }
});

// 处理拖拽的文件
async function processDraggedFiles(files) {
    for (const filePath of files) {
        const result = await invoke('process_file', { path: filePath });
        // 显示结果...
    }
}
```

### 后端实现
```rust
// 文件: src-tauri/src/main.rs
// 行数: 247-264

#[tauri::command]
async fn process_file(path: String, state: State<'_, AppState>) -> Result<String, String> {
    let config = state.config.lock().map_err(|e| e.to_string())?.clone();
    
    // 调用文件操作模块
    let result = file_ops::organize_single_file(&path, &config.rules)
        .map_err(|e| e.to_string())?;
    
    // 更新统计
    let mut stats = state.stats.lock().map_err(|e| e.to_string())?;
    stats.files_processed += 1;
    if !result.is_empty() {
        stats.files_organized += 1;
    }
    
    Ok(result)
}
```

### Tauri 配置
```json
// 文件: src-tauri/tauri.conf.json
{
  "tauri": {
    "windows": [
      {
        "fileDropEnabled": true  // ✅ 必须启用
      }
    ]
  }
}
```

---

## ✅ 测试确认

### 测试步骤

1. **测试单文件拖拽**
   ```
   操作：拖拽 1 个 PDF 文件
   预期：立即处理，活动日志显示结果
   ```

2. **测试多文件拖拽（<5个）**
   ```
   操作：拖拽 3 个文件
   预期：立即处理，活动日志显示 3 条记录
   ```

3. **测试批量拖拽（≥5个）**
   ```
   操作：拖拽 10 个文件
   预期：弹出批量确认窗口，点击确认后处理
   ```

4. **测试未匹配规则**
   ```
   操作：拖拽一个不匹配任何规则的文件
   预期：显示"⚠️ 未匹配规则"
   ```

5. **测试错误处理**
   ```
   操作：拖拽一个已删除的文件路径
   预期：显示错误消息
   ```

---

## 🎉 总结

拖拽功能已完全恢复并增强：
- ✅ 支持单个和多个文件拖拽
- ✅ 智能批量确认（5个阈值）
- ✅ 详细的活动日志
- ✅ 与自动监控互不干扰
- ✅ 统一的规则引擎

现在您可以：
1. 手动拖拽临时文件快速整理
2. 设置文件夹自动监控持续整理
3. 两种方式结合使用，灵活应对各种场景

---

**享受更高效的文件管理体验！** 🚀

